Файловая организация
====================

main.c

global.[ch]             Общие вспомогательные функции и глобальные настройки

cmdargs.[ch]            Обработка аргументов коммандной строки

lparse.[ch]             Парсинг на лексемы

process.[ch]            Вызывает функции для непоследственной генерации

remap.[ch]              Составление символьных таблиц

func.[ch]               Парсинг функций

alloc.[ch]             Аллокация регистров

emit.[ch]              Генерация ассемблера

Реализация
==========

Первым делом происходит установка параметров компилятора через аргументы
командной строки. Этим занимается функция 'cmdargs_handle' и на это посвещён
весь файл 'cmdargs.c'. Разбор последователен, после него идёт проверка пара-
метров и их дополнение. Самих параметров всего 2: это имена исходного и ре-
зультирующего файлов. Исходный файл должен указываться всегда, а результи-
рующий может быть либо указан непосредственно, либо быль выведел из исход-
ного удаление суффикса '.il', если он конечно есть, и добавлением суффикса
'.s'.

После этого полученные параметры передаются функции process, в которой и
будет выполнена вся работа. В самой process' произходит 3 вещи: инициали-
зируется переменная типа state, которая будет содержать всё внутреннее пред-
ставление промежуточного языка, выполняются первый и второй акты. Тип state
содержит список всех лексем, таблицу внешних идентификаторов, список описа-
ний функций и список вызовов функций.

В первом акте происходит формирование списка всех лексем, переименование
глобальных символов, структурный парсинг функций. Во втором акте происходит
проверка расстановки глобальных идентификаторов и генерация ассемблера.

/* TODO */

Этапы работы

	1. Парсинг на лексемы
	2. Построение структуры
	3. Аллокация регистров
	4. Генерация ассембрера


1.  Парсинг на лексемы
----------------------

Через символы-разделители. Тип лексемы определяется в это-же время.

2. Построение структуры
-----------------------

Структура строится для каждой функции отдельно, последовательно одна за
одной. Сперва выедается заголовок функции, выбираются аргументы. Эти аргу-
менты проверяются на уникальность.

Далее происходит переименование регистровых переменных.

После этого строятся команды и одновременно с этим проверяется их коррект-
ность.

3. Аллокация регистров
----------------------
Цель используемоего алгоритма для аллокации регистров проста: память по воз-
можности не должна использоваться как место хранения переменных. При этом
'вес' переменных не учитывается - все переменных равнозначны.

Аллокация начинается с того, что определяются интервалы жизни переменных.
После этого создаётся копия множества интервалов. Оригинал сортируется по
возврастанию начал, а копия - по возврастанию концов.

Сперва регистры или память назвачаются аргументам функции.

bystart - массив интервалов переменных отсортированный по началам
byend - массив интервалов переменных отсортированный по концам
in_need - структура содержащая живие переменные, которым выдали память.

allocate(bystart, byend, in_need) {
	while (pos = getpos(bystart, byend))
		remove all variables in in_need, whose .end < pos

		if pos taken from byend
			free_var(pos)

		if pos taken from bystart
			allocate_var(pos)

		give_to_inneed()
}

getpos(bystart, byend) {
	pos = POSTYPE_MAX
	mask = not_from_any
	if bystart.first exists and bystart.first.start < pos
		pos = bystart.first.start
		mask = from_bystart
	if byend.first exists and bystart.first.end + 1 < pos
		pos = bystart.first.end + 1
		mask |= from_byend
	return pos
}

free_var(i) {
	while byend.first.end < pos
		i <- extract first from byend

		if i occupied register
			free i.reg
}

allocate_var(pos) {
	while bystart.first.start = pos
		i <- extract first from bystart

		if free registers present
			give i register
		else
			give i memory
			add i to in_need
}

give_to_inneed() {
	while in_need is not empty and free registers present
		i <- take varible from inneed with highest .end
		give i register
}

4. Генерация ассемблера
-----------------------

/* TODO */
