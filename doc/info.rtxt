IL compiler - компилятор промежуточного языка

Промежуточный язык есть упращенная до минумума вариация QBE IL. Он будет
компилироваться в x86_64 nasm ассемблер.
Пока что, единственных тип данных - 64-битное целое (i).

Пример

func i $f(%a, %b)
{
	%1 = add %a, %b
	ret %1
}

Поддерживаемые команды

%i - переменная
i64 - 64-битная константа

	%i add %i, %i                  сложение
	%i copy (%i|i64)               копирование
	ret %i                         возврат значения из функции

Реализация
==========

Этапы работы
************

	1. Парсинг на лексемы
	2. Построение структуры
	3. Аллокация регистров
	4. Генерация ассембрера


1.  Парсинг на лексемы
----------------------
Через символы-разделители. Тип лексемы определяется в это-же время.

2. Построение структуры
-----------------------
Структура строится для каждой функции отдельно, последовательно одна за
одной. Сперва выедается заголовок функции, выбираются аргументы. Эти аргу-
менты проверяются на уникальность.

Далее происходит переименование регистровых переменных.

После этого строятся команды и одновременно с этим проверяется их коррект-
ность.

3. Аллокация регистров
----------------------
Цель используемоего алгоритма для аллокации регистров проста: память по воз-
можности не должна использоваться как место хранения переменных. При этом
'вес' переменных не учитывается - все переменных равнозначны.

Аллокация начинается с того, что определяются интервалы жизни переменных.
После этого создаётся копия множества интервалов. Оригинал сортируется по
возврастанию начал, а копия - по возврастанию концов.

Сперва регистры или память назвачаются аргументам функции.

bystart - массив интервалов переменных отсортированный по началам
byend - массив интервалов переменных отсортированный по концам
in_need - структура содержащая живие переменные, которым выдали память.

foreach i in bystart
	foreach j in in_need
		if j.end < i.start
			remove j from in_need

	foreach j in byend, whose end < i.start
		if j occupy register
			free j.register
		remove j from byend

	if free register present
		give i register
	else
		give i memory
		add i to in_need

	foreach j in in_need
		if all registers occupied
			break;
		give j register
		remove j from in_need

Файловая организация
====================

main.c

global.[ch]             Общие вспомогательные функции и глобальные настройки

cmdargs.[ch]            Обработка аргументов коммандной строки

lparse.[ch]             Парсинг на лексемы

process.[ch]            Вызывает функции для непоследственной генерации

remap.[ch]              Составление символьных таблиц

func.[ch]               Парсинг функций

alloc.[ch]             Аллокация регистров

*emit.[ch]              Ренерация ассемблера
