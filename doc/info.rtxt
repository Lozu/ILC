IL compiler - компилятор промежуточного языка

Промежуточный язык есть упращенная до минумума вариация QBE IL. Он будет
компилироваться в x86_64 nasm ассемблер.
Пока что, единственных тип данных - 64-битное целое (i).

Пример

func i $f(%a, %b)
{
	%1 = add %a, %b
	ret %1
}

Поддерживаемые команды

%i - переменная
i64 - 64-битная константа

	%i add %i, %i                  сложение
	%i copy (%i|i64)               копирование
	ret %i                         возврат значения из функции

Реализация
==========

Этапы работы
************

	1. Парсинг на лексемы
	2. Построение структуры
	3. Аллокация регистров
	4. Генерация ассембрера


1.  Парсинг на лексемы
----------------------
Через символы-разделители. Тип лексемы определяется в это-же время.

2. Построение структуры
-----------------------
Структура строится для каждой функции отдельно, последовательно одна за
одной. Сперва выедается заголовок функции, выбираются аргументы. Эти аргу-
менты проверяются на уникальность.

Далее происходит переименование регистровых переменных.

После этого строятся команды и одновременно с этим проверяется их коррект-
ность.

3. Аллокация регистров
----------------------
Цель используемоего алгоритма для аллокации регистров проста: память по воз-
можности не должна использоваться как место хранения переменных. При этом
'вес' переменных не учитывается - все переменных равнозначны.

Аллокация начинается с того, что определяются интервалы жизни переменных.
После этого создаётся копия множества интервалов. Оригинал сортируется по
возврастанию начал, а копия - по возврастанию концов.

Сперва регистры или память назвачаются аргументам функции.

bystart - массив интервалов переменных отсортированный по началам
byend - массив интервалов переменных отсортированный по концам
in_need - структура содержащая живие переменные, которым выдали память.

allocate(bystart, byend, in_need) {
	while (pos = getpos(bystart, byend))
		remove all variables in in_need, whose .end < pos

		if pos taken from byend
			free_var(pos)

		if pos taken from bystart
			allocate_var(pos)

		give_to_inneed()
}

getpos(bystart, byend) {
	pos = POSTYPE_MAX
	mask = not_from_any
	if bystart.first exists and bystart.first.start < pos
		pos = bystart.first.start
		mask = from_bystart
	if byend.first exists and bystart.first.end + 1 < pos
		pos = bystart.first.end + 1
		mask |= from_byend
	return pos
}

free_var(i) {
	while byend.first.end < pos
		i <- extract first from byend

		if i occupied register
			free i.reg
}

allocate_var(pos) {
	while bystart.first.start = pos
		i <- extract first from bystart

		if free registers present
			give i register
		else
			give i memory
			add i to in_need
}

give_to_inneed() {
	while in_need is not empty and free registers present
		i <- take varible from inneed with highest .end
		give i register
}

Файловая организация
====================

main.c

global.[ch]             Общие вспомогательные функции и глобальные настройки

cmdargs.[ch]            Обработка аргументов коммандной строки

lparse.[ch]             Парсинг на лексемы

process.[ch]            Вызывает функции для непоследственной генерации

remap.[ch]              Составление символьных таблиц

func.[ch]               Парсинг функций

alloc.[ch]             Аллокация регистров

emit.[ch]              Ренерация ассемблера
